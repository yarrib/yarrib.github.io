[
  {
    "objectID": "posts/post-01-01-2023/index.html",
    "href": "posts/post-01-01-2023/index.html",
    "title": "Why would I blog?",
    "section": "",
    "text": "Why would I blog?\n\nPlus some bonus Python coding\n\n\nPhoto by Ameen Fahmy on Unsplash\nThe main reason I’m starting this blog is because I’ve been hesitant to do so. I prefer not to share too much information, so this is a sort of personal challenge. Also, Jeremy and Rachel over at FastAI are adament about blogging as a means of learning deep learning (or any topic for that matter). I agree with this perspective despite maintaining that the idea of blogging is better than actually doing it. I’ll keep tabs on this perspective over time.\nI’m going to do things a little differently, in my own style, and will probably break a bunch of blogging guidelines. I’m going to be mixing thoughts and ideas with data science code snippets and projects. While I have some ideas for upcoming posts I also am likely to interject random tutorials which I would consider things that are useful to me.\nThe goal of this isn’t to make money or anything like that. It is simply to get comfortable being uncomfortable in posting content and sharing thoughts, ideas and projects. The personal gain I am seeking will be the product of committing to the habit and practicing it.\nSo with that, lets go through a little python code that I find to be indespensible: comprehensions. I find myself interjecting list and dictionary comprehensions in all manner of code I write in Python. For instance, if I need to: filter some data based on a condition, manipulate dictionary keys and values, or update Pandas Dataframe column names. I’ll show those examples below, in contrast with some other methods.\n\n\nComprehensions\nPerform calculations on a list\nFirst we need a list to work with, which is easy enough to create in python:\n\nlist_1 = list(range(25))\nprint(list_1)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]\n\n\nOk, so we have a list. Lets find the odd numbers using loops:\n\nodd_nums = []\nfor item in list_1:\n    if item%2 != 0:\n        odd_nums.append(item)\nprint(odd_nums)\n\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]\n\n\nWell that works, but kind of long winded. A list comp can shorten it up for us:\n\nodd_nums_lc = [item for item in list_1 if item%2 != 0]\nprint(odd_nums_lc)\n\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]\n\n\nSimilar methods also work for nested lists. It should be noted however, that comprehensions can be harder to read, so extensively nested statements might be best being split up or incorporating some sort of loop or helper function.\nGetting some corpus - body of text - into a dictionary of word counts\nWell we need a dict, so lets take some text and do a word count. We will use the first 2 paragraphs from the Wikipedia entry for Gandalf\n\ngandalf = \"\"\"\nGandalf is a protagonist in J. R. R. Tolkien's novels The Hobbit and The Lord of the Rings. \nHe is a wizard, one of the Istari order, and the leader of the Fellowship of the Ring. Tolkien took the \nname \"Gandalf\" from the Old Norse \"Catalogue of Dwarves\" (Dvergatal) in the Völuspá.\n\nAs a wizard and the bearer of one of the Three Rings, Gandalf has great power, but works mostly by \nencouraging and persuading. He sets out as Gandalf the Grey, possessing great knowledge and \ntravelling continually. Gandalf is focused on the mission to counter the Dark Lord Sauron by \ndestroying the One Ring. He is associated with fire; his ring of power is Narya, the Ring of \nFire. As such, he delights in fireworks to entertain the hobbits of the Shire, while in great \nneed he uses fire as a weapon. As one of the Maiar, he is an immortal spirit from Valinor, \nbut his physical body can be killed.\n\"\"\"\n\ngandalf\n\n'\\nGandalf is a protagonist in J. R. R. Tolkien\\'s novels The Hobbit and The Lord of the Rings. \\nHe is a wizard, one of the Istari order, and the leader of the Fellowship of the Ring. Tolkien took the \\nname \"Gandalf\" from the Old Norse \"Catalogue of Dwarves\" (Dvergatal) in the Völuspá.\\n\\nAs a wizard and the bearer of one of the Three Rings, Gandalf has great power, but works mostly by \\nencouraging and persuading. He sets out as Gandalf the Grey, possessing great knowledge and \\ntravelling continually. Gandalf is focused on the mission to counter the Dark Lord Sauron by \\ndestroying the One Ring. He is associated with fire; his ring of power is Narya, the Ring of \\nFire. As such, he delights in fireworks to entertain the hobbits of the Shire, while in great \\nneed he uses fire as a weapon. As one of the Maiar, he is an immortal spirit from Valinor, \\nbut his physical body can be killed.\\n'\n\n\nWell as is we have some work to do on the text to clean it up, as is often required. So lets do that. we need to strip special characters, quotes, and some other things.\nSteps: - use a regular expression (regex) to strip out punctuaton - convert everything to lower\n\nimport re\n\ngandalf_filtered = re.sub(r'[^\\w\\s]|\\n', '', gandalf).lower().split(' ')\nprint(gandalf_filtered)\n\n['gandalf', 'is', 'a', 'protagonist', 'in', 'j', 'r', 'r', 'tolkiens', 'novels', 'the', 'hobbit', 'and', 'the', 'lord', 'of', 'the', 'rings', 'he', 'is', 'a', 'wizard', 'one', 'of', 'the', 'istari', 'order', 'and', 'the', 'leader', 'of', 'the', 'fellowship', 'of', 'the', 'ring', 'tolkien', 'took', 'the', 'name', 'gandalf', 'from', 'the', 'old', 'norse', 'catalogue', 'of', 'dwarves', 'dvergatal', 'in', 'the', 'völuspáas', 'a', 'wizard', 'and', 'the', 'bearer', 'of', 'one', 'of', 'the', 'three', 'rings', 'gandalf', 'has', 'great', 'power', 'but', 'works', 'mostly', 'by', 'encouraging', 'and', 'persuading', 'he', 'sets', 'out', 'as', 'gandalf', 'the', 'grey', 'possessing', 'great', 'knowledge', 'and', 'travelling', 'continually', 'gandalf', 'is', 'focused', 'on', 'the', 'mission', 'to', 'counter', 'the', 'dark', 'lord', 'sauron', 'by', 'destroying', 'the', 'one', 'ring', 'he', 'is', 'associated', 'with', 'fire', 'his', 'ring', 'of', 'power', 'is', 'narya', 'the', 'ring', 'of', 'fire', 'as', 'such', 'he', 'delights', 'in', 'fireworks', 'to', 'entertain', 'the', 'hobbits', 'of', 'the', 'shire', 'while', 'in', 'great', 'need', 'he', 'uses', 'fire', 'as', 'a', 'weapon', 'as', 'one', 'of', 'the', 'maiar', 'he', 'is', 'an', 'immortal', 'spirit', 'from', 'valinor', 'but', 'his', 'physical', 'body', 'can', 'be', 'killed']\n\n\nOk, so we have this list of words. Now what? Well to get the word counts we have a few options: - Cheat and use collections.Counter - Use a for loop\nIn either case we can get our word counts into a dict, but using a dictionary comprehension isn’t super efficient because we need to do some information retrieval from the dict. An alternative is using collections.defaultdict.\n\n# method 1: collections.Counter\nfrom collections import Counter\n\ngandalf_wc_v1 = Counter(gandalf_filtered)\nprint(gandalf_wc_v1)\n\nCounter({'the': 20, 'of': 11, 'is': 6, 'he': 6, 'gandalf': 5, 'and': 5, 'a': 4, 'in': 4, 'one': 4, 'ring': 4, 'as': 4, 'great': 3, 'fire': 3, 'r': 2, 'lord': 2, 'rings': 2, 'wizard': 2, 'from': 2, 'power': 2, 'but': 2, 'by': 2, 'to': 2, 'his': 2, 'protagonist': 1, 'j': 1, 'tolkiens': 1, 'novels': 1, 'hobbit': 1, 'istari': 1, 'order': 1, 'leader': 1, 'fellowship': 1, 'tolkien': 1, 'took': 1, 'name': 1, 'old': 1, 'norse': 1, 'catalogue': 1, 'dwarves': 1, 'dvergatal': 1, 'völuspáas': 1, 'bearer': 1, 'three': 1, 'has': 1, 'works': 1, 'mostly': 1, 'encouraging': 1, 'persuading': 1, 'sets': 1, 'out': 1, 'grey': 1, 'possessing': 1, 'knowledge': 1, 'travelling': 1, 'continually': 1, 'focused': 1, 'on': 1, 'mission': 1, 'counter': 1, 'dark': 1, 'sauron': 1, 'destroying': 1, 'associated': 1, 'with': 1, 'narya': 1, 'such': 1, 'delights': 1, 'fireworks': 1, 'entertain': 1, 'hobbits': 1, 'shire': 1, 'while': 1, 'need': 1, 'uses': 1, 'weapon': 1, 'maiar': 1, 'an': 1, 'immortal': 1, 'spirit': 1, 'valinor': 1, 'physical': 1, 'body': 1, 'can': 1, 'be': 1, 'killed': 1})\n\n\n\n# method 2: for loop\n\ngandalf_wc_v2 = {}\n# Count number of times each word comes up in list of words (in dictionary)\nfor w in gandalf_filtered:\n    if w not in gandalf_wc_v2.keys():\n        gandalf_wc_v2[w] = 1\n    else:\n        gandalf_wc_v2[w] += 1\n\nprint(gandalf_wc_v2)\n\n{'gandalf': 5, 'is': 6, 'a': 4, 'protagonist': 1, 'in': 4, 'j': 1, 'r': 2, 'tolkiens': 1, 'novels': 1, 'the': 20, 'hobbit': 1, 'and': 5, 'lord': 2, 'of': 11, 'rings': 2, 'he': 6, 'wizard': 2, 'one': 4, 'istari': 1, 'order': 1, 'leader': 1, 'fellowship': 1, 'ring': 4, 'tolkien': 1, 'took': 1, 'name': 1, 'from': 2, 'old': 1, 'norse': 1, 'catalogue': 1, 'dwarves': 1, 'dvergatal': 1, 'völuspáas': 1, 'bearer': 1, 'three': 1, 'has': 1, 'great': 3, 'power': 2, 'but': 2, 'works': 1, 'mostly': 1, 'by': 2, 'encouraging': 1, 'persuading': 1, 'sets': 1, 'out': 1, 'as': 4, 'grey': 1, 'possessing': 1, 'knowledge': 1, 'travelling': 1, 'continually': 1, 'focused': 1, 'on': 1, 'mission': 1, 'to': 2, 'counter': 1, 'dark': 1, 'sauron': 1, 'destroying': 1, 'associated': 1, 'with': 1, 'fire': 3, 'his': 2, 'narya': 1, 'such': 1, 'delights': 1, 'fireworks': 1, 'entertain': 1, 'hobbits': 1, 'shire': 1, 'while': 1, 'need': 1, 'uses': 1, 'weapon': 1, 'maiar': 1, 'an': 1, 'immortal': 1, 'spirit': 1, 'valinor': 1, 'physical': 1, 'body': 1, 'can': 1, 'be': 1, 'killed': 1}\n\n\nI will use either method, but tend to prefer writing less code that I have to maintain. If there is a helper class or function that is in a stable release of a library, it makes life easier to use it.\nBecause it doesn’t matter much which one we use for our example, we’ll just grab gandalf_wc_v2 and get the top N values that exceed a certain word length. There are a ton of ways to do this, we will just use plain python.\n\nWe could have done this in one more line on our collections.Counter method call like this: gandalf_wc_v1.most_common(n=5)\n\nBut that is too easy, so let’s do it longhand:\n\n# key value pairs where key is >= 3\ngandalf_wl_geq_3 = {k:v for k,v in gandalf_wc_v2.items() if len(k) >= 3}\n# top N counts\nn = 5\ntop_n = sorted(gandalf_wl_geq_3.values(), reverse=True)[:n]\n#[20, 5, 5, 4, 4]\n\n# finally, a fun use of a dict comp:\n{k:v for k,v in gandalf_wl_geq_3.items() if v in top_n}\n\n{'gandalf': 5, 'the': 20, 'and': 5, 'one': 4, 'ring': 4}\n\n\nLast but perhaps one of the best, comprehensions on Pandas Dataframe columns\nlets create a dataframe with some sample data. To make it interesting I’ll use some comprehensions and other native python capabilities to create a dataset for this example, instead of using Iris or Housing.\n\nimport pandas as pd\nimport numpy as np\nfrom itertools import combinations\n\nyrs = range(2018,2022,1)\ncities = 'Bozeman, MT', 'Spokane, WA', 'Bangor, ME', 'White Plains, NY', 'Sedona, AZ'\ncat1 = ['wizard', 'ranger', 'elf', 'hutt', 'orc', 'nazgul', 'numenorean', 'deciever']\n\ncolnames = 'year','city','role','points'\nds = [[y,c,k, np.random.randint(-10, 10)] for k in cat1 for c in cities for y in yrs]\n\ndf = pd.DataFrame(ds, columns=colnames)\ndisplay(df.head(3), df.shape)\n\n\n\n\n\n  \n    \n      \n      year\n      city\n      role\n      points\n    \n  \n  \n    \n      0\n      2018\n      Bozeman, MT\n      wizard\n      3\n    \n    \n      1\n      2019\n      Bozeman, MT\n      wizard\n      -9\n    \n    \n      2\n      2020\n      Bozeman, MT\n      wizard\n      -8\n    \n  \n\n\n\n\n(160, 4)\n\n\nSo we have some meaningless data. Now lets group by to get a multiindex that we want to manipulate, the whole point of this little exercise.\n\ndfg = df.groupby(by=['city', 'role']).agg({'points': ['mean','sum', np.std]}).reset_index()\ndfg.head(3)\n\n\n\n\n\n  \n    \n      \n      city\n      role\n      points\n    \n    \n      \n      \n      \n      mean\n      sum\n      std\n    \n  \n  \n    \n      0\n      Bangor, ME\n      deciever\n      4.50\n      18\n      3.872983\n    \n    \n      1\n      Bangor, ME\n      elf\n      0.75\n      3\n      7.889867\n    \n    \n      2\n      Bangor, ME\n      hutt\n      -1.25\n      -5\n      5.560276\n    \n  \n\n\n\n\nSo this isn’t super useful for anything. Now normally some dataset for machine learning or what not will have a much broader set of columns (a.k.a. features), but the concept is pretty much the same. Just remember to work on manageable chunks and don’t get intimidated by a long chain of transformations.\n\nprint(f'Initial column list: {dfg.columns}')\n\nInitial column list: MultiIndex([(  'city',     ''),\n            (  'role',     ''),\n            ('points', 'mean'),\n            ('points',  'sum'),\n            ('points',  'std')],\n           )\n\n\nSo first I’ll demonstrate updating this with a list comprehension. This is a bit more complex of a list comprehension in that in incorporates a conditional ''.join in the output. Basically what is happening is we are looking at each tuple in the multiindex, and if the last item is an empty string, we underscore join all but the lst element, otherwise we join the whole thing.\n\ndfg_copy1 = dfg.copy()\ndfg_copy1.columns = ['_'.join(list(x) if len(x[-1]) > 0 else x[:-1]) for x in dfg_copy1.columns]\ndfg_copy1.head(2)\n\n\n\n\n\n  \n    \n      \n      city\n      role\n      points_mean\n      points_sum\n      points_std\n    \n  \n  \n    \n      0\n      Bangor, ME\n      deciever\n      4.50\n      18\n      3.872983\n    \n    \n      1\n      Bangor, ME\n      elf\n      0.75\n      3\n      7.889867\n    \n  \n\n\n\n\nThere is another way, however, that is pretty clever. It is more of a functional style and I’m fairly certain I’ve seen it used in the Fast AI course or notebooks in addition to numerous tutorials on the internet. We will be using the map function over our columns.\n\ndfg_copy2 = dfg.copy()\ndfg_copy2.columns = dfg_copy2.columns.map(lambda x : '_'.join(x) if x[-1] == '_' else x[0])\n\ndfg_copy2.head(3)\n\n\n\n\n\n  \n    \n      \n      city\n      role\n      points\n      points\n      points\n    \n  \n  \n    \n      0\n      Bangor, ME\n      deciever\n      4.50\n      18\n      3.872983\n    \n    \n      1\n      Bangor, ME\n      elf\n      0.75\n      3\n      7.889867\n    \n    \n      2\n      Bangor, ME\n      hutt\n      -1.25\n      -5\n      5.560276\n    \n  \n\n\n\n\nWhile this is really quick and easy if there isn’t any weird conditions (e.g. you can just use {dataframe_name}.columns.map('_'.join)), above we only have the multiindex on some columns, so handling the city and role columns differently is something useful to do for readbility. So there you have it, a bonus method of map + lambda to achieve the same goal as a list comprehension.\n\nWell for now that is plenty of information. Hopefully this helps a future task of yours regardless of your proficiency in technical terminonology."
  },
  {
    "objectID": "til.html",
    "href": "til.html",
    "title": "My TILs (Today I Learned)",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\n\n\n\n\n\n\nmatplotlib demo\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Yarri Bryn",
    "section": "",
    "text": "Hi, I’m Yarri\nI am a Data Scientist at Wipfli LLP. This blog is for sharing my thoughts on various topics in data science, helpful tips, and things I’ve learned."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Yarri",
    "section": "",
    "text": "Yarri Bryn is a Data Scientist at Wipfli LLP. Yarri is married with one kiddo, Mateo, whom he hopes will grow up to be curious. He also likes golf, spending time outdoors, and various athletic and non-athletic hobbies.\n\n\nUniversity of Wisconsin - Eau Claire | Eau Claire, WI M.S. in Data Science | Sept 2019 - May 2022\nUniversity of Northern Iowa | Cedar Falls, Iowa B.A. in Marketing Management | Sept 2009 - May 2013\n\n\n\nWipfli LLP | Data Scientist / Data Engineer | January 2022-Present\nMinneapolis Park and Recreation Board | Parking & Business Systems Professional\nSelf-Employed | Professional Golfer (limited success) | September 2017 - October 2017\n\n\n  \n  \n  \n    \n     LinkedIn\n  \n  \n    \n     Github"
  },
  {
    "objectID": "about.html#certifications",
    "href": "about.html#certifications",
    "title": "About Yarri",
    "section": "Certifications",
    "text": "Certifications"
  },
  {
    "objectID": "about.html#skills",
    "href": "about.html#skills",
    "title": "About Yarri",
    "section": "Skills",
    "text": "Skills\n\nSoft Skills\n\nCommunication\nCollaboration\nProblem Solving\n\nTechnical Skills\n\nData Engineering\nMachine Learning\nDevOps/MLOps\nInfrastructure as Code\n\nTools\n\nMicrosoft: Azure Synapse Analytics (and ADF), AzureML, SQL Server, PowerBI\nOpen Source: Git, Shell (bash/zsh), Anaconda, Docker\nOther: Terraform\n\nLanguages\n\nPython\nSQL\nSpark/PySpark"
  },
  {
    "objectID": "til/demo.html",
    "href": "til/demo.html",
    "title": "matplotlib demo",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Greetings!",
    "section": "",
    "text": "Below are my most recent blog posts.\n\n\n\n\n\n\n\nWhy would I blog?\n\n\n\n\n\n\n\nnews\n\n\ngeneral\n\n\npython\n\n\ncomprehensions\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2023\n\n\nYarri Bryn\n\n\n\n\n\n\nNo matching items"
  }
]